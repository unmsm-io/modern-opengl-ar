---
id: "step4-ar-marker"
tag: "v4-ar-marker"
title: "ArUco Marker + View/Proj"
summary: "OpenCV detecta el marcador y convertimos rvec/tvec a vista GL. Mostramos ejes 3D gruesos para confirmar tracking."
durationMin: 20
author: "Railly Hugo"
authorImageUrl: "/hugo-profile.webp"
pubDate: "2025-06-04"
files: []
path: "workshop/step4-ar-marker"
---

import Alert     from "../../components/Alert.astro";
import StepGuide from "../../components/StepGuide.astro";
import CodeBlock from "../../components/CodeBlock.astro";

<Alert type="info">
  **Tag del repo:** <code>v4-ar-marker</code> ‚Üí <code>git checkout v4-ar-marker</code>.
</Alert>

---

## Detecci√≥n de marcadores AR

En este paso implementamos **detecci√≥n ArUco** con OpenCV y mostramos **ejes 3D gruesos** para confirmar que el tracking funciona correctamente.

### Integraci√≥n ARTracker

La clase `ARTracker` maneja autom√°ticamente la detecci√≥n de marcadores:

```cpp
ARTracker ar;

// En el loop principal:
ar.grabFrame();  // Captura frame + detecta marcadores

// Verificar detecci√≥n
if (ar.markerVisible()) {
  // Marker ID 0 detectado - mostrar ejes 3D
  glm::mat4 VP = ar.proj() * ar.view();  // Matrices de c√°mara real
}
```

### Feedback de detecci√≥n

Sistema de logging para confirmar que el tracking funciona:

```cpp
static bool markerDetectedBefore = false;

if (ar.markerVisible() && !markerDetectedBefore) {
  LOG_INF("üéØ MARKER DETECTED! ID 0 - showing THICK 3D axes");
  markerDetectedBefore = true;
} else if (!ar.markerVisible() && markerDetectedBefore) {
  LOG_INF("‚ùå Marker lost - point camera back at ArUco marker");
  markerDetectedBefore = false;
}
```

### Ejes 3D gruesos (cilindros)

En lugar de l√≠neas finas, usamos **cilindros 3D** para m√°xima visibilidad:

```cpp
// Crear geometr√≠a de cilindro grueso
float axisRadius = 0.003f;  // 3mm de radio - muy visible!
float axisLength = 0.05f;   // 5cm de largo
AxisGeometry thickAxis = createThickAxis(axisRadius, axisLength, 8);
```

### Generaci√≥n de geometr√≠a cil√≠ndrica

Funci√≥n para crear cilindros proceduralmente:

```cpp
AxisGeometry createThickAxis(float radius, float length, int segments = 8) {
  std::vector<float> vertices;
  std::vector<unsigned int> indices;
  
  // Crear cilindro a lo largo del eje Z (0,0,0) ‚Üí (0,0,length)
  for (int i = 0; i <= segments; i++) {
    float theta = 2.0f * M_PI * i / segments;
    float x = radius * cos(theta);
    float y = radius * sin(theta);
    
    // C√≠rculo inferior (z=0)
    vertices.insert(vertices.end(), {x, y, 0.0f});
    // C√≠rculo superior (z=length)  
    vertices.insert(vertices.end(), {x, y, length});
  }
  
  // Generar √≠ndices para los lados del cilindro
  for (int i = 0; i < segments; i++) {
    // Dos tri√°ngulos por quad lateral
    indices.insert(indices.end(), {bottom1, top1, bottom2});
    indices.insert(indices.end(), {bottom2, top1, top2});
  }
}
```

### Renderizado de ejes XYZ

Cada eje se renderiza como un cilindro rotado apropiadamente:

```cpp
// X axis - Rojo (rotar cilindro Z hacia +X)
glm::mat4 xTransform = glm::rotate(glm::mat4(1.0f), glm::radians(90.0f), glm::vec3(0, 1, 0));
glm::mat4 xMVP = VP * xTransform;
glUniform3f(glGetUniformLocation(axisShader.id(), "uColor"), 1.0f, 0.0f, 0.0f);
glUniformMatrix4fv(glGetUniformLocation(axisShader.id(), "MVP"), 1, GL_FALSE, &xMVP[0][0]);
glDrawElements(GL_TRIANGLES, thickAxis.indexCount, GL_UNSIGNED_INT, 0);

// Y axis - Verde (rotar cilindro Z hacia +Y)
glm::mat4 yTransform = glm::rotate(glm::mat4(1.0f), glm::radians(-90.0f), glm::vec3(1, 0, 0));
// ... similar para Y y Z
```

### Shaders para ejes

Shaders simples para renderizar cilindros de color s√≥lido:

```cpp
static const char *AXIS_VSHADER = R"(
#version 410 core
layout(location=0) in vec3 aPos;
uniform mat4 MVP;
void main(){ gl_Position = MVP * vec4(aPos, 1.0); }
)";

static const char *AXIS_FSHADER = R"(
#version 410 core
uniform vec3 uColor;
out vec4 FragColor;
void main(){ FragColor = vec4(uColor, 1.0); }
)";
```

### Ventajas de los cilindros gruesos

**vs. glLineWidth():**
- ‚úÖ **Sin limitaciones** de OpenGL Core Profile
- ‚úÖ **Grosor garantizado** (3mm de radio = 6mm de di√°metro)
- ‚úÖ **Visible desde cualquier √°ngulo**
- ‚úÖ **Futuro-compatible** para efectos adicionales

**C√≥digo vs. l√≠neas finas:**
```cpp
// ‚ùå L√≠neas finas (limitadas a 1px en macOS)
glLineWidth(3.0f);  // Ignorado en Core Profile
glDrawArrays(GL_LINES, 0, 2);

// ‚úÖ Cilindros gruesos (sin limitaciones)
glDrawElements(GL_TRIANGLES, thickAxis.indexCount, GL_UNSIGNED_INT, 0);
```

### Debug de pose del marcador

Logging peri√≥dico de la posici√≥n del marcador:

```cpp
static int poseDebugCounter = 0;
if (++poseDebugCounter % 60 == 0) { // cada 2 segundos
  glm::mat4 view = ar.view();
  glm::vec3 markerPos = glm::vec3(view[3]); // parte de traslaci√≥n
  LOG_INF("Marker ID 0 pose - position: (%.3f, %.3f, %.3f) - THICK axes visible!", 
          markerPos.x, markerPos.y, markerPos.z);
}
```

## Interpretaci√≥n de los ejes

### Sistema de coordenadas ArUco
- **X (rojo)**: Hacia la derecha del marcador
- **Y (verde)**: Hacia arriba del marcador  
- **Z (azul)**: Saliendo del marcador hacia la c√°mara

### Verificaci√≥n visual
- Los ejes deben **permanecer fijos** al marcador
- **No deben temblar** excesivamente
- **Colores claros** y **grosor visible** desde 30-50cm

## Checklist de validaci√≥n

| √çtem | OK |
|------|----|
| C√°mara muestra video en tiempo real | ‚úÖ |
| ArUco marker ID 0 se detecta correctamente | ‚úÖ |
| Ejes 3D aparecen/desaparecen con el marcador | ‚úÖ |
| Ejes son gruesos y claramente visibles | ‚úÖ |
| X=rojo, Y=verde, Z=azul identificables | ‚úÖ |
| Tracking estable sin temblores excesivos | ‚úÖ |

<Alert type="success">
  **¬°Tracking AR funcionando!** Los **ejes gruesos 3D** confirman que la detecci√≥n y pose estimation funcionan correctamente.  
  El sistema est√° listo para agregar objetos 3D que floten sobre el marcador.
</Alert>

<Alert type="tip">
  **Para mejor tracking:** buena iluminaci√≥n, marcador plano, c√°mara estable, y distancia 30-50cm del marcador.
</Alert>

---

## Siguiente: Sistema Solar 3D

Con el tracking AR funcionando perfectamente, el siguiente paso a√±ade el **sistema solar 3D** que flota sobre el marcador.

```bash
git checkout v5-solar-system
``` 